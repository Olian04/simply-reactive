var simplyReactive=function(e){"use strict";const s={},u=(t=s,e=>(e.key in t||(t[e.key]={value:e.default,subscribers:{}}),{key:e.key,set:s=>{if("function"==typeof s){const u=s;t[e.key].value=u(t[e.key].value)}else t[e.key].value=s;Object.values(t[e.key].subscribers).forEach((e=>e()))},get:()=>t[e.key].value,subscribe:(s,u)=>(t[e.key].subscribers[s]=u,()=>{delete t[e.key].subscribers[s]})}));var t;const n=(e=>s=>{const u=()=>{e[s.key].isDirty=!0,Object.values(e[s.key].subscribers).forEach((e=>e()))},t=t=>{const n=t.subscribe(s.key,u);return e[s.key].unsubscribeFunctions.push(n),t.get()};s.key in e||(e[s.key]={value:null,isDirty:!0,subscribers:{},unsubscribeFunctions:[]});return{key:s.key,get:()=>(e[s.key].isDirty&&(e[s.key].unsubscribeFunctions.forEach((e=>e())),e[s.key].unsubscribeFunctions=[],e[s.key].value=s.get({get:t}),e[s.key].isDirty=!1),e[s.key].value),subscribe:(u,t)=>(e[s.key].subscribers[u]=t,()=>{delete e[s.key].subscribers[u]})}})(s);function i(e,s,u,t){return new(u||(u=Promise))((function(n,i){function r(e){try{o(t.next(e))}catch(e){i(e)}}function c(e){try{o(t.throw(e))}catch(e){i(e)}}function o(e){var s;e.done?n(e.value):(s=e.value,s instanceof u?s:new u((function(e){e(s)}))).then(r,c)}o((t=t.apply(e,s||[])).next())}))}const r=(e=>s=>{const u=()=>{e[s.key].isDirty=!0,Object.values(e[s.key].subscribers).forEach((e=>e()))},t=t=>{const n=t.subscribe(s.key,u);return e[s.key].unsubscribeFunctions.push(n),t.get()};s.key in e||(e[s.key]={value:null,isDirty:!0,subscribers:{},unsubscribeFunctions:[]});return{key:s.key,get:()=>i(void 0,void 0,void 0,(function*(){return e[s.key].isDirty&&(e[s.key].unsubscribeFunctions.forEach((e=>e())),e[s.key].unsubscribeFunctions=[],e[s.key].value=yield s.get({get:t}),e[s.key].isDirty=!1),e[s.key].value})),subscribe:(u,t)=>(e[s.key].subscribers[u]=t,()=>{delete e[s.key].subscribers[u]})}})(s);var c;!function(e){e.Discard="discard",e.Flush="flush",e.FlushDebounced="flush-debounced"}(c||(c={}));const o=((e,s=1)=>(u,t)=>{var n;const i=String((null==t?void 0:t.key)||s++);i in e||(e[i]={notifyTimeoutId:void 0,debounceDuration:null!==(n=null==t?void 0:t.debounceDuration)&&void 0!==n?n:0,unsubscribeFunctions:[]});const r=()=>{e[i].unsubscribeFunctions.forEach((e=>e())),e[i].unsubscribeFunctions=[]},o=s=>{const u=s.subscribe(i,(()=>{-1!==e[i].debounceDuration?(e[i].unsubscribeFunctions.push(u),clearTimeout(e[i].notifyTimeoutId),e[i].notifyTimeoutId=setTimeout(b,e[i].debounceDuration)):b()}));return s.get()},b=()=>{r(),u({get:o})};return b(),(s=c.Discard)=>{if(void 0===e[i])return;const t=()=>{u({get:e=>e.get()})},n=()=>{r(),clearTimeout(e[i].notifyTimeoutId),e[i].notifyTimeoutId=void 0,e[i].debounceDuration=0,e[i].unsubscribeFunctions=[],delete e[i]};switch(s){case c.Discard:n();break;case c.Flush:t(),n();break;case c.FlushDebounced:clearTimeout(e[i].notifyTimeoutId),setTimeout((()=>{t(),n()}),0);default:throw new Error(`Unknown DebounceCleanupStrategy: ${s}`)}}})(s);return e.createAtom=u,e.createEffect=o,e.createResource=r,e.createSelector=n,e.visualizeDependencyGraph=()=>{const e=["graph TD;"];for(let[u,t]of Object.entries(s))if("subscribers"in t)for(let s of Object.keys(t.subscribers))e.push(`${u}--\x3e${s};`);return e.join("\n\t")},e}({});
